# LeetCode 1010 - Pairs of Songs With Total Durations Divisible by 60

📌 **Descripción del problema**

Dado un arreglo `time`, donde cada valor representa la duración de una canción, se debe contar cuántos pares de índices `(i, j)` cumplen:

- `i < j`
- `(time[i] + time[j]) % 60 == 0`

🧠 **Idea principal y por qué funciona**

La condición puede transformarse usando residuos módulo 60:

```text
(a + b) % 60 == 0
<=>
(a % 60 + b % 60) % 60 == 0
```

Para cada canción con residuo `r = t % 60`, su complemento es:

```text
c = (60 - r) % 60
```

Se usa un arreglo de frecuencias `freq[0..59]`:
- `freq[x]` = cuántas canciones ya vistas tienen residuo `x`

Paso de conteo:
1. Calcular `r` y `c`.
2. Sumar `freq[c]` al resultado.
3. Incrementar `freq[r]`.

Esto funciona porque en cada paso se cuentan solo pares con canciones anteriores, por lo que cada par se registra una sola vez y se respeta `i < j`.

Ejemplo corto (`[30, 20, 150, 100, 40]`):
- `30` -> `r=30`, `c=30`, suma 0
- `20` -> `r=20`, `c=40`, suma 0
- `150` -> `r=30`, `c=30`, suma 1
- `100` -> `r=40`, `c=20`, suma 1
- `40` -> `r=40`, `c=20`, suma 1
- Total: `3`

⚙️ **Implementación (Python)**

```py
from typing import List

class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        freq = [0] * 60
        contador = 0

        for t in time:
            r = t % 60
            c = (60 - r) % 60

            contador += freq[c]
            freq[r] += 1

        return contador
```

📊 **Complejidad**

| Métrica | Complejidad |
|---|---|
| Tiempo | `O(n)` |
| Espacio | `O(1)` |

🔑 **Patrones de pensamiento algorítmico**

- Transformación del dato original (valor -> residuo).
- Conteo incremental con frecuencias.
- Búsqueda de complementos para cumplir una condición de suma.

🧭 **Señales para usar este enfoque**

- Se piden pares que cumplan divisibilidad (`% k == 0`).
- La condición depende de sumas con objetivo modular.
- Se busca contar sin recorrer todos los pares explícitamente.

🎯 **Conclusión formativa**

La clave fue pasar de duraciones completas a residuos y usar conteo acumulado. Esta forma de pensar simplifica la condición del problema y permite una solución eficiente y fácil de justificar.
