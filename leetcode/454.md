# LeetCode 454 - 4Sum II

📌 **Descripción del problema**

Se reciben cuatro arreglos enteros `nums1`, `nums2`, `nums3`, `nums4` del mismo tamaño. Se debe contar cuántas tuplas `(i, j, k, l)` cumplen:

```text
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
```

🧠 **Idea principal y por qué funciona**

La ecuación puede reorganizarse como:

```text
(a + b) = -(c + d)
```

Con esa transformación:
1. Se cuentan frecuencias de todas las sumas `a + b`.
2. Para cada suma `c + d`, se busca su complemento `-(c + d)`.

La estructura clave es un diccionario (`dict`) de frecuencias:
- clave: suma
- valor: cuántas veces aparece

Esto funciona porque cada coincidencia entre una suma y su complemento representa combinaciones válidas de índices, y el conteo por frecuencia evita recalcular pares repetidos.

Ejemplo corto:
- Si `a+b=4` aparece 3 veces
- y `c+d=-4` aparece 2 veces
- entonces aportan `3 * 2 = 6` tuplas válidas

⚙️ **Implementación (Python)**

```py
from typing import List

class Solution:
    def fourSumCount(
        self,
        nums1: List[int],
        nums2: List[int],
        nums3: List[int],
        nums4: List[int]
    ) -> int:
        freq_ab = {}
        result = 0

        for a in nums1:
            for b in nums2:
                s = a + b
                freq_ab[s] = freq_ab.get(s, 0) + 1

        for c in nums3:
            for d in nums4:
                t = c + d
                result += freq_ab.get(-t, 0)

        return result
```

📊 **Complejidad**

| Métrica | Complejidad |
|---|---|
| Tiempo | `O(n^2)` |
| Espacio | `O(n^2)` |

🔑 **Patrones de pensamiento algorítmico**

- Reescritura algebraica de la condición objetivo.
- Conteo por frecuencias con hashmap.
- Separación del problema en dos mitades (Meet in the Middle).

🧭 **Señales para usar este enfoque**

- El problema pide contar combinaciones de varios arreglos.
- La condición puede expresarse en términos de complemento.
- Se necesita evitar generar todas las combinaciones explícitamente.

🎯 **Conclusión formativa**

La mejora nace de transformar la condición matemática y aprovechar conteo por frecuencias. Este razonamiento permite resolver el problema de forma escalable y con una estructura lógica fácil de validar.
