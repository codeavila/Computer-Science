# 454 - Aprendizaje del algoritmo

Archivo del ejercicio: [454.py](454.py)

Este README explica el aprendizaje clave al resolver LeetCode 454 (4Sum II).

## Objetivo del problema

Dado cuatro arreglos `nums1`, `nums2`, `nums3` y `nums4`, contar cuántas tuplas `(i, j, k, l)` cumplen:

```text
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
```

## Idea principal

La fuerza bruta usa 4 loops y cuesta `O(n^4)`, lo cual no escala.

La transformación útil es:

```text
a + b + c + d = 0
(a + b) = -(c + d)
```

Con eso, dividimos el problema en dos mitades y contamos frecuencias con hashmap.

## Estrategia (paso a paso)

1. Crear un diccionario `freq_ab` para contar sumas `a + b`.
2. Recorrer `nums1` y `nums2`, acumulando frecuencia de cada suma.
3. Inicializar `result = 0`.
4. Recorrer `nums3` y `nums4`, calcular `t = c + d`.
5. Sumar `freq_ab.get(-t, 0)` al resultado.
6. Retornar `result`.

## Conceptos que practicaste

### 1) HashMap con `dict`

```py
freq_ab = {}
```

Guarda frecuencias por clave (la suma) en tiempo promedio constante.

### 2) Conteo por frecuencias

```py
freq_ab[s] = freq_ab.get(s, 0) + 1
```

Evita recalcular combinaciones y permite multiplicar posibilidades.

#### ¿Cómo funciona `dict.get()`?

Sintaxis:

```py
diccionario.get(clave, valor_por_defecto)
```

Comportamiento:
- Si la clave existe, devuelve su valor.
- Si no existe, devuelve `valor_por_defecto` (sin lanzar error).

Ejemplo pequeño:

```py
freq = {}
freq[4] = freq.get(4, 0) + 1   # 1
freq[4] = freq.get(4, 0) + 1   # 2
freq[7] = freq.get(7, 0) + 1   # 1
print(freq)  # {4: 2, 7: 1}
```

Sin `get()`, esto podría fallar:

```py
freq[4] = freq[4] + 1  # KeyError si 4 no existe
```

### 3) Complemento aditivo

```py
result += freq_ab.get(-t, 0)
```

Si `c + d = t`, necesitamos `a + b = -t` para llegar a cero.

### 4) Meet in the Middle

Se parte un problema grande en dos bloques, se procesa cada bloque y luego se combinan resultados.

### 5) Acumulador de resultado

```py
result = 0
```

Suma el número total de tuplas válidas sin almacenar cada tupla.

## Métodos de `dict` útiles en este contexto

### `get(clave, default)`

Lee un valor sin error si la clave no existe.

```py
valor = freq_ab.get(-t, 0)
```

### `items()`

Itera clave y valor al mismo tiempo.

```py
for suma, frecuencia in freq_ab.items():
    print(suma, frecuencia)
```

### `keys()`

Obtiene solo claves.

```py
for suma in freq_ab.keys():
    print(suma)
```

### `values()`

Obtiene solo valores.

```py
for frecuencia in freq_ab.values():
    print(frecuencia)
```

### `setdefault(clave, default)`

Inserta la clave con `default` si no existe y devuelve el valor.

```py
freq = {}
freq.setdefault(10, 0)
freq[10] += 1
```

### `update(...)`

Actualiza/mezcla diccionarios.

```py
a = {1: 2}
a.update({2: 3})
# a == {1: 2, 2: 3}
```

### `pop(clave, default)`

Elimina y devuelve una clave.

```py
x = a.pop(2, 0)  # devuelve 3
```

## Plantilla mental reutilizable

1. Detectar combinaciones costosas por fuerza bruta.
2. Reescribir la ecuación para separar en grupos.
3. Contar un grupo con hashmap.
4. Resolver el otro grupo buscando complementos.

Patrón aplicable a:
- Two Sum
- 3Sum
- Subarray Sum Equals K
- Top K Frequent Elements
- Contains Duplicate

## Complejidad

- Tiempo: `O(n^2)`
- Espacio: `O(n^2)`

## Errores comunes

1. Mantener estado en `self` y no reiniciarlo por llamada.
2. Intentar resolver con 4 ciclos anidados (`O(n^4)`).
3. Olvidar buscar el complemento con signo (`-t`).
4. Sobrescribir frecuencias en vez de acumular.

## Cierre

La mejora viene de pensar en estructura y álgebra, no en más loops.
Separar en mitades y contar frecuencias reduce el problema de `O(n^4)` a `O(n^2)`.
