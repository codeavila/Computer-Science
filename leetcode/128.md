# 128 - Aprendizaje del algoritmo

Archivo del ejercicio: [128.py](128.py)

Este README resume el aprendizaje real detrás de resolver LeetCode 128 (Longest Consecutive Sequence), no solo el resultado.

## Objetivo del problema

Dada una lista desordenada de enteros, devolver la longitud de la secuencia consecutiva más larga.

Ejemplo:
- Entrada: `[100, 4, 200, 1, 3, 2]`
- Salida: `4` (por la secuencia `1, 2, 3, 4`)

Restricción clave:
- El algoritmo debe ser `O(n)`.

## Idea principal que desbloquea el problema

La pregunta más repetida es: "Existe el siguiente número?".

Si haces eso sobre una `list`, es lento (`O(n)` por búsqueda). La mejora es convertir a `set` para búsquedas `O(1)` promedio.

Patrón:
- Estructura lenta -> estructura rápida
- `list` -> `set`

## Estrategia correcta (paso a paso)

1. Convertir `nums` a set para eliminar duplicados y buscar rápido.
2. Recorrer cada número del set.
3. Solo iniciar una secuencia cuando el número sea inicio real:
   `n - 1` no está en el set.
4. Expandir la secuencia con `while` mientras exista `n + 1`.
5. Guardar el máximo con `max()`.

## Conceptos que practicaste

### 1) `List[int]` (type hints)

```py
from typing import List

def longestConsecutive(self, nums: List[int]) -> int:
```

Qué aporta:
- Mejor legibilidad
- Ayuda del IDE/linter
- Documentación viva del contrato de la función

### 2) `set(nums)`

```py
num_set = set(nums)
```

Qué aporta:
- Elimina duplicados
- Búsqueda de pertenencia rápida

```py
x in num_set  # O(1) promedio
```

### 3) Operador `in`

```py
if x in num_set:
```

Se usa para validar existencia muchas veces. En este problema, es la operación central.

### 4) `max(a, b)`

```py
best = max(best, streak)
```

Mantiene el mejor resultado sin un `if` extra.

### 5) `while`

```py
while current + 1 in num_set:
```

Ideal cuando no sabes cuántas iteraciones habrá, depende de los datos.

### 6) Acumuladores

```py
streak = 1
best = 0
```

Guardan estado parcial y resultado global.

## Plantilla mental reutilizable

Este patrón se repite en muchos problemas:
- Two Sum
- Contains Duplicate
- Valid Anagram
- Longest Substring
- Intersection of Arrays

Plantilla:
1. Detecta operación repetida costosa.
2. Cambia a estructura con acceso rápido (`set` o `dict`).
3. Evita trabajo redundante (aquí: empezar solo desde inicios).
4. Mantén respuesta incremental con acumuladores.

## Complejidad

- Tiempo: `O(n)`
- Espacio: `O(n)`

## Errores comunes (y cómo evitarlos)

1. Ordenar la lista (`sort`) y romper la meta de `O(n)`.
2. Recorrer lista con duplicados en vez de set.
3. Iniciar secuencia desde cualquier número (retrabajo).
4. Errores de sintaxis en ternario:

Incorrecto:
```py
(a + 1) if cond else a = 0
```

Correcto:
```py
a = (a + 1) if cond else 0
```

## Cierre

Lo importante no fue solo "hacer que funcione", sino entender por qué funciona rápido. Ese razonamiento es lo transferible a otros problemas.
