# 128 - Aprendizaje del algoritmo

Archivo del ejercicio: [128.py](128.py)

Este README explica el aprendizaje clave al resolver LeetCode 128 (Longest Consecutive Sequence).

## Objetivo del problema

Dada una lista desordenada de enteros, devolver la longitud de la secuencia consecutiva más larga.

Ejemplo:
- Entrada: `[100, 4, 200, 1, 3, 2]`
- Salida: `4` (secuencia `1, 2, 3, 4`)

Restricción clave:
- El algoritmo debe ejecutarse en `O(n)`.

## Idea principal

La pregunta repetida es: "¿existe el siguiente número?".

- En `list`, esa búsqueda cuesta `O(n)`.
- En `set`, esa búsqueda cuesta `O(1)` promedio.

Por eso, el paso que desbloquea el problema es:
- `list` -> `set`

## Estrategia (paso a paso)

1. Convertir `nums` a `set` para eliminar duplicados y buscar rápido.
2. Recorrer cada número del set.
3. Solo iniciar secuencia cuando `n - 1` no está en el set.
4. Expandir con `while` mientras exista `n + 1`.
5. Guardar el máximo con `max()`.

## Conceptos que practicaste

### 1) `List[int]` (type hints)

```py
from typing import List

def longestConsecutive(self, nums: List[int]) -> int:
```

Aporta legibilidad, ayuda del IDE y documentación del contrato de la función.

### 2) `set(nums)`

```py
num_set = set(nums)
```

Permite búsquedas de pertenencia rápidas:

```py
x in num_set  # O(1) promedio
```

### 3) Operador `in`

```py
if x in num_set:
```

Es la operación central del problema, porque valida existencia constantemente.

### 4) `max(a, b)`

```py
best = max(best, streak)
```

Actualiza el mejor resultado sin condicional extra.

### 5) `while`

```py
while current + 1 in num_set:
```

Sirve cuando el número de iteraciones depende de los datos.

### 6) Acumuladores

```py
streak = 1
best = 0
```

Guardan estado parcial y resultado global.

## Plantilla mental reutilizable

1. Detectar operación repetida costosa.
2. Cambiar a estructura de acceso rápido (`set` o `dict`).
3. Evitar trabajo redundante (aquí: iniciar solo en comienzos de secuencia).
4. Mantener el resultado con acumuladores.

Patrón aplicable a:
- Two Sum
- Contains Duplicate
- Valid Anagram
- Longest Substring
- Intersection of Arrays

## Complejidad

- Tiempo: `O(n)`
- Espacio: `O(n)`

## Errores comunes

1. Ordenar (`sort`) y romper la meta de `O(n)`.
2. Recorrer lista con duplicados en vez de set.
3. Iniciar secuencia desde cualquier número, generando retrabajo.
4. Error de sintaxis con ternario.

Incorrecto:

```py
(a + 1) if cond else a = 0
```

Correcto:

```py
a = (a + 1) if cond else 0
```

## Cierre

La clave no es solo que funcione: es entender por qué funciona en `O(n)`.
Ese criterio se transfiere a muchos problemas de hashing y secuencias.
