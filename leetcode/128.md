# LeetCode 128 - Longest Consecutive Sequence

📌 **Descripción del problema**

Dado un arreglo de enteros sin ordenar `nums`, se debe devolver la longitud de la secuencia consecutiva más larga.

Ejemplo:
- Entrada: `[100, 4, 200, 1, 3, 2]`
- Salida: `4` (secuencia: `1, 2, 3, 4`)

Condición relevante:
- Se busca una solución con complejidad de tiempo `O(n)`.

🧠 **Idea principal y por qué funciona**

La decisión clave es convertir la lista a `set` para hacer búsquedas rápidas de pertenencia.

- En `list`, preguntar "¿existe x?" cuesta `O(n)`.
- En `set`, esa misma pregunta cuesta `O(1)` promedio.

Para evitar trabajo repetido, solo se inicia una secuencia desde valores que sean comienzo real:
- Un número `n` es inicio si `n - 1` **no** está en el set.

Desde cada inicio, se avanza con `while` (`n+1`, `n+2`, ...), contando la longitud de esa secuencia.

Esto funciona porque:
- Cada secuencia se expande una sola vez desde su inicio.
- No se recalculan secuencias desde puntos intermedios.

Ejemplo rápido:
- Set: `{100, 4, 200, 1, 3, 2}`
- Inicios: `100`, `200`, `1`
- Expansión desde `1`: `1 -> 2 -> 3 -> 4` (longitud 4)

⚙️ **Implementación (Python)**

```py
from typing import List

class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        num_set = set(nums)
        longest = 0

        for n in num_set:
            if (n - 1) not in num_set:
                current = n
                streak = 1

                while (current + 1) in num_set:
                    current += 1
                    streak += 1

                longest = max(longest, streak)

        return longest
```

📊 **Complejidad**

| Métrica | Complejidad |
|---|---|
| Tiempo | `O(n)` |
| Espacio | `O(n)` |

🔑 **Patrones de pensamiento algorítmico**

- Transformar estructura de datos para mejorar acceso (`list` -> `set`).
- Detectar inicios válidos para evitar recorridos redundantes.
- Usar acumuladores para mantener mejor resultado global.

🧭 **Señales para usar este enfoque**

- El problema exige validar existencia de elementos muchas veces.
- Se trabaja con secuencias o continuidad en valores.
- Hay riesgo de repetir cómputo si se comienza desde cualquier punto.

🎯 **Conclusión formativa**

El aprendizaje central es que una buena representación de datos cambia el rendimiento del algoritmo. En este caso, pensar en pertenencia rápida y en inicios de secuencia permite una solución clara, correcta y eficiente.
